package evolved;

import robocode.*;
import robocode.util.*;
import java.util.*;
import java.awt.Color;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Point2D;

//  Based on work by Nic McPhee
//  Implements Iterative Linear Targeting from RoboWiki http://robowiki.net/wiki/Linear_Targeting
//  Implements Oldest Scanned Radar from RoboWiki http://robowiki.net/wiki/Melee_Radar

/*
 * This template has the following fields that need to be filled in:
 *   id : an id used in the generation of the name of the class.
 *	 code : legal evolved Java code.
 */
 
public class DarkSoul_${id} extends AdvancedRobot {

	//VARIABLES USED BY EVOLUTION
	double moveDirection = 1;
	
	// Oldest Scanned Radar
	static LinkedHashMap<String, Double> enemyHashMap;
	static double scanDir;
	static Object sought;
	
	
	
//- run -------------------------------------------------------------------------------------------------------------------------------------
	public void run()
	{
		scanDir = 1;
    	enemyHashMap = new LinkedHashMap<String, Double>(5, 2, true);
		
		setColors(Color.black,Color.black,Color.black, Color.red, Color.red);
		setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		

			
    	while(true) {
        	setTurnRadarRightRadians(scanDir * Double.POSITIVE_INFINITY);
       		scan();
       		
       		${code}
    	}
	}
	
//- hitting walls ------------------------------------------------------------------------------------------------------
	public void onHitWall(HitWallEvent e) {
		${code}
	}
	
//- hitting other robots ---------------------------------------------------------------------------------------------
	public void onHitRobot(HitRobotEvent e) {
		${code}
	}

//- being hit by bullet ----------------------------------------------------------------------------------------------
	public void onHitByBullet(HitByBulletEvent e) {
		${code}
	}
	
//- on enemy death ---------------------------------------------------------------------------------------------
	public void onRobotDeath(RobotDeathEvent e) {
    enemyHashMap.remove(e.getName());
    sought = null;
	}
	
//- scan event ------------------------------------------------------------------------------------------------------------------------------
	public void onScannedRobot(ScannedRobotEvent e){
		String name = e.getName();
	    LinkedHashMap<String, Double> ehm = enemyHashMap;
	 
	    ehm.put(name, getHeadingRadians() + e.getBearingRadians());
	 
	    if ((name == sought || sought == null) && ehm.size() == getOthers()) {
		scanDir = Utils.normalRelativeAngle(ehm.values().iterator().next()
	            - getRadarHeadingRadians());
	        sought = ehm.keySet().iterator().next();
	    }

		double bulletPower = Math.min(3.0,getEnergy());
		double myX = getX();
		double myY = getY();
		double absoluteBearing = getHeadingRadians() + e.getBearingRadians();
		double enemyX = getX() + e.getDistance() * Math.sin(absoluteBearing);
		double enemyY = getY() + e.getDistance() * Math.cos(absoluteBearing);
		double enemyHeading = e.getHeadingRadians();
		double enemyVelocity = e.getVelocity();
		 
		 
		double deltaTime = 0;
		double battleFieldHeight = getBattleFieldHeight(), 
		       battleFieldWidth = getBattleFieldWidth();
		double predictedX = enemyX, predictedY = enemyY;
		while((++deltaTime) * (20.0 - 3.0 * bulletPower) < 
		      Point2D.Double.distance(myX, myY, predictedX, predictedY)){		
			predictedX += Math.sin(enemyHeading) * enemyVelocity;	
			predictedY += Math.cos(enemyHeading) * enemyVelocity;
			if(	predictedX < 18.0 
				|| predictedY < 18.0
				|| predictedX > battleFieldWidth - 18.0
				|| predictedY > battleFieldHeight - 18.0){
				predictedX = Math.min(Math.max(18.0, predictedX), 
		                    battleFieldWidth - 18.0);	
				predictedY = Math.min(Math.max(18.0, predictedY), 
		                    battleFieldHeight - 18.0);
				break;
			}
		}
		double theta = Utils.normalAbsoluteAngle(Math.atan2(
		    predictedX - getX(), predictedY - getY()));
		 
		setTurnRadarRightRadians(
		    Utils.normalRelativeAngle(absoluteBearing - getRadarHeadingRadians()));
		setTurnGunRightRadians(Utils.normalRelativeAngle(theta - getGunHeadingRadians()));
		fire(bulletPower);
	}
	
}